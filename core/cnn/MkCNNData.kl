//************************************************************************************************//
//                                                                                                //
//  Code part of the project MLKL                                                                 //
//                                                                                                //
//  couet.julien@gmail.com                                                                        //
//                                                                                                //
//************************************************************************************************//

require MLKL, MkCNNCpp;
require FileIO, Util, OpenImageIO;
 
/**
  The AlembicArchiveReader is a wrapper for the AlembicIArchive. 
  It provides access to the higher level reader objects such as the AlembicXformReader.
  \example

  require MLKL;

  operator entry() {}

  \endexample
*/

struct MkCNNData {
  Index train_labels[];
  Index test_labels[];
  Float64 train_images[][];
  Float64 test_images[][];
};

/// Display in the console
public MkCNNData.display(String data_origin, MkCNNConfig config) {
  report("\n\n\n-------------------- " + data_origin + " data --------------------");
  report("Training number  : " + this.train_images.size());
  report("Testing number   : " + this.test_images.size());
  report("Image size       : " + Index(sqrt(this.train_images[0].size())) + 
         "x" + Index(sqrt(this.train_images[0].size())));
  report("Train image path : " + config.train_images_path);
  report("Train label path : " + config.train_labels_path);
  report("Test image path  : " + config.test_images_path);
  report("Test label path  : " + config.test_labels_path);
}

inline NormalizeImage(Float64 scale_min, Float64 scale_max, io Float64 image[]) {
  for(Index j=0; j<image.size(); ++j)
    image[j] = (image[j] / 255.0) * (scale_max - scale_min) + scale_min;
}

inline NormalizeImages(Float64 scale_min, Float64 scale_max, io Float64 images[][]) {
  for(Index i=0; i<images.size(); ++i)
    NormalizeImage(scale_min, scale_max, images[i]);
}

/// Load MNIST data for training
public MkCNNData.loadTrainingMNIST!(MkCNNConfig config) {
  MkCNNCpp mnist();
  this.train_images = mnist.readImages_MNIST(config.train_images_path, -1.0, 1.0, 2, 2);
  this.test_images = mnist.readImages_MNIST(config.test_images_path, -1.0, 1.0, 2, 2);
  this.train_labels = mnist.readLabels_MNIST(config.train_labels_path);
  this.test_labels = mnist.readLabels_MNIST(config.test_labels_path); 
  this.display("MNIST", config);
}

/// Load MNIST data for training
/// Load a 8bits .png image
function Float64[] MkCNNData.loadValidationMNIST!(String path, Float64 scale_min, Float64 scale_max) {
  
  OpenImageInput oiio(path);
  OpenImageSpec spec = oiio.spec();
  OpenImageTypeDesc desc = OpenImageTypeDesc(OpenImage_BASETYPE_UINT8, OpenImage_AGGREGATE_SCALAR, OpenImage_VECSEMANTICS_NOXFORM);

  Byte bytes[];
  bytes.resize(spec.get_full_width() * spec.get_full_height() * spec.get_nchannels());
  
  Data data = bytes.data();
  oiio.read_image(desc, data, 0, 0, 0);

  Float64 image[];
  image.resize(spec.get_full_width() * spec.get_full_height());
  for(Index i=0; i<image.size(); ++i)
    image[i] = Float64(bytes[3*i]);
  
  // Normalize the iamge between 0 and 1
  NormalizeImage(scale_min, scale_max, image);
  return image;
}

public MkCNNData LoadTrainingCIFAR(
  MkCNNConfig config, 
  Boolean rgb, 
  Float64 scale_min, 
  Float64 scale_max) 
{ 
  MkCNNData data;
  MkCNNCpp cifar();
  FilePath file_path(config.train_images_path);
  String cifar_folder = file_path.parentPath().string();

  for(Index p=0; p<5; ++p)
  {
    String train_images_path = cifar_folder + "/data_batch_" + (p+1) + ".bin";
    if(p < 4)
    {
      Index train_labels[];
      Float64 train_images[][];
      cifar.readBatch_CIFAR(train_images_path, rgb, train_images, train_labels);
      for(Index i=0; i<train_images.size(); ++i) 
      {
        data.train_images.push(train_images[i]);
        data.train_labels.push(train_labels[i]);
      }
    }
    else if (p == 4)
      cifar.readBatch_CIFAR(train_images_path, rgb, data.test_images, data.test_labels);
  }
  data.display("CIFAR", config);

  if(scale_min > -1 && scale_max > -1)
  {
    NormalizeImages(0.0, 1.0, data.train_images);
    NormalizeImages(0.0, 1.0, data.test_images);
  }

  return data;
}

public Float64[][] LoadValidationCIFAR(
  MkCNNConfig config, 
  Boolean rgb, 
  Float64 scale_min, 
  Float64 scale_max) 
{ 
  Index validation_labels[];
  Float64 validation_images[][];
  MkCNNCpp cifar();
  cifar.readBatch_CIFAR(config.test_images_path, rgb, validation_images, validation_labels);
  if(scale_min > -1 && scale_max > -1)
    NormalizeImages(0.0, 1.0, validation_images);
  return validation_images;
}
 