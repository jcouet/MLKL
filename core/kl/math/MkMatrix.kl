/**************************************************************************************************/
/*                                                                                                */
/*  Informations :                                                                                */
/*      This code is part of the project KL_ML                                                    */
/*                                                                                                */
/*  Contacts :                                                                                    */
/*      couet.julien@gmail.com                                                                    */
/*                                                                                                */
/**************************************************************************************************/

require KL_ML;
 

/**************************************************************************************************/
/*                                          3. Matrix Operations                                  */
/*
function MkMaths.inverse(
  io UInt32 size,
  io Float32 matrix[],
  io Float32 inverse[])
{
  MeUtilsWrapper maths_wrapper;
  MeUtilsWrapper_Inverse(
    maths_wrapper, 
    size, 
    matrix,
    inverse);
} 

function MkMaths.eigen(
  io Index nb_eigen_val,
  io UInt32 size,
  io Float32 matrix[],
  io Float32 eigen_values[],
  io Vec3 eigen_vectors[][])
{
  MeUtilsWrapper maths_wrapper;
  MeUtilsWrapper_Eigen(
    maths_wrapper, 
    nb_eigen_val, 
    size, 
    matrix,
    eigen_values, 
    eigen_vectors);
} 

function MkMaths.eigenVNL(
  UInt32 matrix_width,
  UInt32 matrix_height,
  Float32 matrix[],
  io Float32 eigen_values[],
  io Float32 eigen_vectors[])
{
  MeUtilsWrapper maths_wrapper;
  UInt32 matrix_width_ = matrix_width;
  UInt32 matrix_height_ = matrix_height;
  Float32 matrix_[] = matrix;

  MeUtilsWrapper_VNLEigen_Float(
    maths_wrapper,
    matrix_width_, 
    matrix_height_,
    matrix_,
    eigen_values, 
    eigen_vectors);
} 

function MkMaths.eigenVNL(
  Vec3 matrix[],
  io Float32 eigen_values[],
  io Vec3 eigen_vectors[])
{
  Vec3 matrix_[] = matrix;
  MeUtilsWrapper maths_wrapper;

  MeUtilsWrapper_VNLEigen_Vec3(
    maths_wrapper, 
    matrix_,
    eigen_values, 
    eigen_vectors);
} 
*/
/*                                          end Matrix Operations                                 */
/**************************************************************************************************/

                                      /***********************/
 
/**************************************************************************************************/
/*                                         6. Matrix Decomposition                                */
operator TestDecomposition2<<<i>>>(
  UInt32 k,
  Float32 a[][],
  io Float32 l[][], 
  io Float32 u[][]) 
{
  Float32 sum=0; 
  for(SInt32 p=0; p<k-1; p++)
    sum += l[i+k][p]*u[p][k];
  l[i+k][k] = a[i+k][k]-sum;
}

operator TestDecomposition3<<<j>>>(
  UInt32 k,
  Float32 a[][],
  io Float32 l[][], 
  io Float32 u[][]) 
{
  Float32 sum=0;
  for(SInt32 p=0; p<k-1; ++p)
    sum += l[k][p]*u[p][j+(k+1)];
  u[k][j+(k+1)] = (a[k][j+(k+1)]-sum)/l[k][k];
}

operator TestDecomposition<<<k>>>(
  UInt32 n,
  Float32 a[][],
  io Float32 l[][], 
  io Float32 u[][]) 
{
  Float32 sum;
  SInt32 i, j, p;

  u[k][k]=1;
  TestDecomposition2<<<n-k>>>(k, a, l, u);
  TestDecomposition3<<<n-(k+1)>>>(k, a, l, u);
}

operator ResizeLU<<<i>>>(
  UInt32 n,
  io Float32 l[][], 
  io Float32 u[][])
{
  l[i].resize(n);
  u[i].resize(n);
}

operator TestFinding<<<i>>>(
  UInt32 n,
  Float32 b[],
  Float32 l[][], 
  io Float32 z[]) 
{
  Float32 sum=0;
  for(SInt32 p=0; p<i; ++p)
    sum += l[i][p]*z[p];
  z[i] = (b[i]-sum)/l[i][i];
}

operator TestFinding2<<<i>>>(
  UInt32 n,
  Float32 z[],
  Float32 u[][], 
  io Float32 x[]) 
{
  SInt32 i_temp = (n-1)-i;
  Float32 sum=0;
  for(SInt32 p=n-1; p>=i_temp; --p)
    sum += u[i_temp][p]*x[p];
  x[i_temp] = (z[i_temp]-sum)/u[i_temp][i_temp];
}

function MkMaths.decomposeLU(
  Float32 a[][],
  Float32 b[],
  io Float32 x[]) 
{
  Boolean isOk = true;
  Index n = a.size();
  Float32 l[][], u[][], z[], sum;
  SInt32 i, j, k, p;

  for(i=0; i<n; ++i) {
    if(a[i].size() != n) 
      isOk = false;
  }
  if(b.size() != n)
    isOk = false;

  if(isOk) {
    l.resize(n);
    u.resize(n);
    z.resize(n);
    x.resize(n);
    ResizeLU<<<n>>>(n, l, u);
 

    // LU decomposition 
    report("\n\nDecomposition"); 
    TestDecomposition<<<n>>>(n, a, l, u);
    report("\n\nDecomposition"); 
 

    // FINDING Z; LZ=b 
    // forward subtitution method
    TestFinding<<<n>>>(n, b, l, z);
    TestFinding2<<<n>>>(n, z, u, x);
    // for(i=0; i<n; ++i) {              
    //   sum=0;
    //   for(p=0; p<i; ++p)
    //     sum += l[i][p]*z[p];
    //   z[i] = (b[i]-sum)/l[i][i];
    // }
    // FINDING X; UX=Z 
    // for(i=n-1; i>=0; --i) {
    //   sum=0;
    //   for(p=n-1; p>=i; --p)
    //     sum += u[i][p]*x[p];
    //   x[i] = (z[i]-sum)/u[i][i];
    // }

    // DISPLAYING SOLUTION 
    // report("Set of solution is");
    // for(i=0; i<n; ++i) {
    //   if(b[i] > 0.0)
    //     report("i: " + i + " b: " + b[i] + " z: " + z[i] + " x: " + x[i]);
    // }
  }
}

/*
function Boolean MeLUDecomposition.luDecomposition2!(
  Float32 m[][], 
  SInt32 n, 
  io Float32 det) 
{
  // Factors "m" matrix SInt32o A=LU where L is lower triangular and U is upper
  // triangular. The matrix is overwritten by LU with the diagonal elements
  // of L (which are unity) not stored. This must be a square n x n matrix.
  // ri[n] and irow[n] are scratch vectors used by LUBackSubstitution.
  // d is returned +-1 indicating that the
  // number of row SInt32erchanges was even or odd respectively.
  SInt32 i, j, k, ri[];
  ri.resize(n);
  det = 1.0;
  // Initialize the poSInt32er vector.
  for (i = 0 ; i < n; i++)
    ri[i] = i;
  // LU factorization.
  for (SInt32 p = 1 ; p <= n - 1; p++) {
    // Find pivot element.
    for (i = p + 1 ; i <= n; i++) {
      if (abs(m[ri[i-1]][p-1]) > abs(m[ri[p-1]][p-1])) {
        // Switch the index for the p-1 pivot row if necessary.
        SInt32 t = ri[p-1];
        ri[p-1] = ri[i-1];
        ri[i-1] = t;
        det = -det;
      }
    }
    if (m[ri[p-1]][p-1] == 0) {
      // The matrix is singular.
      return false;
    }
    // Multiply the diagonal elements.
    det = det * m[ri[p-1]][p-1];
    // Form multiplier.
    for (i = p + 1 ; i <= n; i++) {
      m[ri[i-1]][p-1] /= m[ri[p-1]][p-1];
      // Eliminate [p-1].
      for (SInt32 j = p + 1 ; j <= n; j++)
        m[ri[i-1]][j-1] -= m[ri[i-1]][p-1] * m[ri[p-1]][j-1];
    }
  }
  det = det * m[ri[n-1]][n-1];
  return det != 0.0;
}
*/
/*                                         end Matrix Decomposition                               */
/**************************************************************************************************/
