/**************************************************************************************************/
/*                                                                                                */
/*  Informations :                                                                                */
/*      This code is part of the project MLKL                                                     */
/*                                                                                                */
/*  Contacts :                                                                                    */
/*      couet.julien@gmail.com                                                                    */
/*                                                                                                */
/**************************************************************************************************/

require Math;
require MLKL; 

/**
  The AlembicArchiveReader is a wrapper for the AlembicIArchive. 
  It provides access to the higher level reader objects such as the AlembicXformReader.
  \example

  require MLKL;

  operator entry() {
    
  }

  \endexample
*/


/**************************************************************************************************/
/*                                              Loss functions                                    */
const Index MK_LOSS_FUNC_MSE = 0;
const Index MK_LOSS_FUNC_CE = 1;
 
/// Interface for loss function 
interface MkCNNLossFunctionInterface {
  Float32 f(Float32 y, Float32 t);
  Float32 df(Float32 y, Float32 t);
  Index mode();
  String modeAsStr();
};

/// Base class for loss function 
object MkCNNLossFunctionBase : MkCNNLossFunctionInterface {
  protected Index mode; // Mode, use to id the class
};

/// Return the current mode, either MK_LOSS_FUNC_CE or MK_LOSS_FUNC_MSE
public Index MkCNNLossFunctionBase.mode() {
  return this.mode;
}

/// Return the current mode as string
public String MkCNNLossFunctionBase.modeAsStr() {
  if(this.mode == MK_LOSS_FUNC_MSE)
    return "MK_LOSS_FUNC_MSE";
  else if(this.mode == MK_LOSS_FUNC_CE)
    return "MK_LOSS_FUNC_CE";
  else
    return "MK_LOSS_FUNC_UNKNOWN";
}

/// Return the value of the function at point x
/// To be overload
public Float32 MkCNNLossFunctionBase.f(Float32 y, Float32 t) {
  return 0.0;
}

/// Return the value of the function derivate point x
/// To be overload
public Float32 MkCNNLossFunctionBase.df(Float32 y, Float32 t) {
  return 0.0;
}


/// Mean Square error 
object MkCNNLossFunctionMSE : MkCNNLossFunctionBase {};

function MkCNNLossFunctionMSE() {
  this.mode = MK_LOSS_FUNC_MSE;
}

public Float32 MkCNNLossFunctionMSE.f(Float32 y, Float32 t) {
  return (y - t) * (y - t) / 2.0;
}

public Float32 MkCNNLossFunctionMSE.df(Float32 y, Float32 t) {
  return y - t;
}

 
/// Cross-Entropy 
object MkCNNLossFunctionCE : MkCNNLossFunctionBase {};

function MkCNNLossFunctionCE() {
  this.mode = MK_LOSS_FUNC_CE;
}

public Float32 MkCNNLossFunctionCE.f(Float32 y, Float32 t) {
  return -t * log(y) - (1.0 - t) * log(1.0 - y);
}

public Float32 MkCNNLossFunctionCE.df(Float32 y, Float32 t) {
  return (y - t) / (y * (1 - y));
}
/*                                              Loss functions                                    */
/**************************************************************************************************/

                                          /***********************/

/**************************************************************************************************/
/*                                             Neuron functions                                   */
const Index MK_NEURON_FUNC_IDENTITY = 0;
const Index MK_NEURON_FUNC_SIGMOID = 1;
const Index MK_NEURON_FUNC_RECTIFIEDLINEAR = 2;
const Index MK_NEURON_FUNC_TANH = 3;
 
/// Interface for activation function 
interface MkCNNNeuronFunctionInterface {
  Float64 f(Float64 x);
  Float64 df(Float64 x);
  Vec2 scale();
  Index mode();
  String modeAsStr();
};

/// Base class for activation function 
object MkCNNNeuronFunctionBase : MkCNNNeuronFunctionInterface {
  protected Index mode; // Mode
};

/// Return the current mode
public Index MkCNNNeuronFunctionBase.mode() {
  return this.mode;
}

/// Return the current mode as string
public String MkCNNNeuronFunctionBase.modeAsStr() {

  if(this.mode == MK_NEURON_FUNC_IDENTITY)
    return "MK_NEURON_FUNC_IDENTITY";
    
  else if(this.mode == MK_NEURON_FUNC_SIGMOID)
    return "MK_NEURON_FUNC_SIGMOID";

  else if(this.mode == MK_NEURON_FUNC_RECTIFIEDLINEAR)
    return "MK_NEURON_FUNC_RECTIFIEDLINEAR";

  else if(this.mode == MK_NEURON_FUNC_TANH)
    return "MK_NEURON_FUNC_TANH";

  else
    return "MK_NEURON_UNKNOWN";
}

/// Return the value of the function at point x
/// To be overload
public Float64 MkCNNNeuronFunctionBase.f(Float64 x) {
  return 0.0;
}

/// Return the value of the function derivate point x
/// To be overload
public Float64 MkCNNNeuronFunctionBase.df(Float64 x) {
  return 0.0;
}

/// Return the current scale
/// To be overload
public Vec2 MkCNNNeuronFunctionBase.scale() {
  return Vec2(1.0, 1.0);
}


/// Identity 
object MkCNNNeuronFunctionIdentity : MkCNNNeuronFunctionBase {};

function MkCNNNeuronFunctionIdentity() {
  this.mode = MK_NEURON_FUNC_IDENTITY;
}

public Float64 MkCNNNeuronFunctionIdentity.f(Float64 x) {
  return x;
}

public Float64 MkCNNNeuronFunctionIdentity.df(Float64 x) {
  return 1;
}

public Vec2 MkCNNNeuronFunctionIdentity.scale() {
  return Vec2(0.1, 0.9);
}


/// Sigmoid
object MkCNNNeuronFunctionSigmoid : MkCNNNeuronFunctionBase {};

function MkCNNNeuronFunctionSigmoid() {
  this.mode = MK_NEURON_FUNC_SIGMOID;
}

public Float64 MkCNNNeuronFunctionSigmoid.f(Float64 x) {
  return 1.0 / (1.0 + exp(-x));
}

public Float64 MkCNNNeuronFunctionSigmoid.df(Float64 x) {
  return x * (1.0 - x);
}

public Vec2 MkCNNNeuronFunctionSigmoid.scale() {
  return Vec2(0.1, 0.9);
}


/// Linear
object MkCNNNeuronFunctionRectifiedLinear : MkCNNNeuronFunctionBase {};

function MkCNNNeuronFunctionRectifiedLinear() {
  this.mode = MK_NEURON_FUNC_RECTIFIEDLINEAR;
}

public Float64 MkCNNNeuronFunctionRectifiedLinear.f(Float64 x) {
  return Math_max(0.0, x); 
}

public Float64 MkCNNNeuronFunctionRectifiedLinear.df(Float64 x) {
  return (x > 0.0) ? 1.0 : 0.0;
}

public Vec2 MkCNNNeuronFunctionRectifiedLinear.scale() {
  return Vec2(0.1, 0.9);
}


/// Tangeante hyperbolic
object MkCNNNeuronFunctionTanH : MkCNNNeuronFunctionBase {};

function MkCNNNeuronFunctionTanH() {
  this.mode = MK_NEURON_FUNC_TANH;
}

public Float64 MkCNNNeuronFunctionTanH.f(Float64 x) {
  Float64 ep = exp(x);
  Float64 em = exp(-x); 
  return (ep - em) / (ep + em);
}

public Float64 MkCNNNeuronFunctionTanH.df(Float64 x) {
  return 1.0 - x * x;
}

public Vec2 MkCNNNeuronFunctionTanH.scale() {
  return Vec2(-0.8, 0.8);
}
/*                                             Neuron functions                                   */
/**************************************************************************************************/

