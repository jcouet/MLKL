/**************************************************************************************************/
/*                                                                                                */
/*  Informations :                                                                                */
/*      This code is part of the project MLKL                                                     */
/*                                                                                                */
/*  Contacts :                                                                                    */
/*      couet.julien@gmail.com                                                                    */
/*                                                                                                */
/**************************************************************************************************/

require FileIO, Util;
require MLKL; 

/**
  The AlembicArchiveReader is a wrapper for the AlembicIArchive. 
  It provides access to the higher level reader objects such as the AlembicXformReader.
  \example

  require MLKL;

  operator entry() {}

  \endexample
*/


/**************************************************************************************************/
/*                                          Activation functions                                  */
/// Class for network layers configuration 
struct MkCNNLayerDefs {}; 

/// Parse the layers configuration parameter relative to the activation function
private Boolean MkCNNLayerDefs.parseNeuronFunction(
  String line, 
  io Index neuron_func)
{
  if(line == "id") { 
    neuron_func = MK_NEURON_FUNC_IDENTITY; 
    return true; 
  }
  else if(line == "sig") { 
    neuron_func = MK_NEURON_FUNC_SIGMOID; 
    return true; 
  }
  else if(line == "relu") {
    neuron_func = MK_NEURON_FUNC_RECTIFIEDLINEAR; 
    return true; 
  }
  else if(line == "tanh") { 
    neuron_func = MK_NEURON_FUNC_TANH; 
    return true; 
  }
  else return false;
}

/// TO-DO
/// Parse the layers configuration and create them
private Boolean MkCNNLayerDefs.parseData(
  String layer_name,
  io TextReader reader, 
  io MkCNNLayerInterface layers[]) 
{

  return true;
}

/// Parse the layers configuration and create them
private Boolean MkCNNLayerDefs.parseConvolutional(
  String layer_name,
  io TextReader reader, 
  io MkCNNLayerInterface layers[]) 
{
  Index neuron_func, in_size, window_size;
  Index in_channels, out_channels, params_counter = 0;

  String line = reader.readLine();
  if(line.find("neuron=") > -1) {
    String neuron_type = line.subString(line.find("neuron=") + String("neuron=").length(), line.length());
    if(this.parseNeuronFunction(neuron_type, neuron_func)) 
      params_counter ++;    
    line = reader.readLine();
  }
  if(line.find("filters=") > -1) {
    String filters_str = line.subString(line.find("filters=") + String("filters=").length(), line.length());
    in_size = Index(filters_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }
  if(line.find("filterSize=") > -1) {
    String window_size_str = line.subString(line.find("filterSize=") + String("filterSize=").length(), line.length());
    window_size = Index(window_size_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }
  if(line.find("inChannels=") > -1) {
    String in_channels_str = line.subString(line.find("inChannels=") + String("inChannels=").length(), line.length());
    in_channels = Index(in_channels_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }
  if(line.find("outChannels=") > -1) {
    String out_channels_str = line.subString(line.find("outChannels=") + String("outChannels=").length(), line.length());
    out_channels= Index(out_channels_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }

  report("\nConvolutional Layer " + layer_name);
  if(params_counter != 5) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("neuron_func " + neuron_func);
    report("in_size "         + in_size);
    report("window_size "     + window_size);
    report("in_channels "     + in_channels);
    report("out_channels "    + out_channels);

    //MK_NEURON_FUNC_TANH, 32, 32, 5, 1, 6));
    layers.push(MkCNNLayerConvolutional(
      neuron_func,
      in_size, in_size, window_size,  
      in_channels, out_channels));

    return true;
  }
}

/// Parse the layers configuration and create them
private Boolean MkCNNLayerDefs.parsePooling(
  String layer_name,
  io TextReader reader,
  io MkCNNLayerInterface layers[]) 
{
  Index pool_type, neuron_func, in_size;
  Index in_channels, pooling_size, params_counter = 0;

  String line = reader.readLine();
  if(line.find("pool=") > -1) {
    String pool_type_str = line.subString(line.find("pool=") + String("pool=").length(), line.length());
    if(pool_type_str == "avg") {
      pool_type = 0;
      params_counter ++;    
    }
    else if(pool_type_str == "max") {
      pool_type = 1;
      params_counter ++;    
    }
    line = reader.readLine();
  }
  if(line.find("neuron=") > -1) {
    String neuron_type = line.subString(line.find("neuron=") + String("neuron=").length(), line.length());
    if(this.parseNeuronFunction(neuron_type, neuron_func)) 
      params_counter ++;    
    line = reader.readLine();
  }
  if(line.find("filters=") > -1) {
    String filters_str = line.subString(line.find("filters=") + String("filters=").length(), line.length());
    in_size = Index(filters_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }
  if(line.find("inChannels=") > -1) {
    String in_channels_str = line.subString(line.find("inChannels=") + String("inChannels=").length(), line.length());
    in_channels = Index(in_channels_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }
  if(line.find("poolingSize=") > -1) {
    String pooling_size_str = line.subString(line.find("poolingSize=") + String("poolingSize=").length(), line.length());
    pooling_size= Index(pooling_size_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }

  report("\nPooling Layer " + layer_name);
  if(params_counter != 5) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("pool_type "       + pool_type);
    report("neuron_func " + neuron_func);
    report("in_size "         + in_size);
    report("in_channels "     + in_channels);
    report("pooling_size "    + pooling_size);

    if(pool_type == 0)
      layers.push(MkCNNLayerAveragePooling(
        neuron_func,in_size, in_size,  
        in_channels, pooling_size));
    else
      layers.push(MkCNNLayerMaxPooling(
        neuron_func,in_size, in_size,  
        in_channels, pooling_size));
    return true;
  }
}

/// Parse the layers configuration and create them
private Boolean MkCNNLayerDefs.parseFully(
  String layer_name,
  io TextReader reader, 
  io MkCNNLayerInterface layers[]) 
{
  Index neuron_func, in_channels, out_channels, params_counter = 0;

  String line = reader.readLine();
  if(line.find("neuron=") > -1) {
    String neuron_type = line.subString(line.find("neuron=") + String("neuron=").length(), line.length());
    if(this.parseNeuronFunction(neuron_type, neuron_func)) 
      params_counter ++;    
    line = reader.readLine();
  }
  if(line.find("inChannels=") > -1) {
    String in_channels_str = line.subString(line.find("inChannels=") + String("inChannels=").length(), line.length());
    in_channels = Index(in_channels_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }
  if(line.find("outChannels=") > -1) {
    String out_channels_str = line.subString(line.find("outChannels=") + String("poolingSize=").length(), line.length());
    out_channels = Index(out_channels_str.toInteger());
    params_counter ++;  
    line = reader.readLine();  
  }

  report("\nFully-Connected Layer " + layer_name);
  if(params_counter != 3) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("neuron_func " + neuron_func);
    report("in_channels "     + in_channels);
    report("out_channels "    + out_channels);
    layers.push(MkCNNLayerFully(neuron_func, in_channels, out_channels));
    return true;
  }
}

/// Parse the layers configuration and create them
public Boolean MkCNNLayerDefs.parse(String path_def, io MkCNNLayerInterface layers[]) {

  TextReader reader();
  if(!reader.open(path_def)) return false;

  report("\n--- Definition ---");
  while(!reader.eof()) 
  {
    String line = reader.readLine();
 
    // Pass comment
    if(line[0] == "#") 
      line = reader.readLine();

    // If we hit a new layer
    if(line[0] == "[")
    {
      String layer_name = line;
      String layer_type = reader.readLine();

      if(layer_type == "type=data") 
      {
        if(!this.parseData(layer_name, reader, layers)) 
          return false;
      }
      else if(layer_type == "type=conv") 
      {
        if(!this.parseConvolutional(layer_name, reader, layers)) 
          return false;
      }
      else if(layer_type == "type=pool") 
      {
        if(!this.parsePooling(layer_name, reader, layers)) 
          return false;
      }
      else if(layer_type == "type=fc") 
      {
        if(!this.parseFully(layer_name, reader, layers)) 
          return false;
      }
    }
  }

  return reader.close();
}
/*                                              Loss functions                                    */
/**************************************************************************************************/

                                          /***********************/

/**************************************************************************************************/
/*                                          Activation functions                                  */
/// TO-DO
/// Class for network layers parameters 
struct MkCNNLayerParams {}; 

/// TO-DO
/// Parse the layers initial parameters
public Boolean MkCNNLayerParams.parse(String path_params, io MkCNNLayerInterface layers[]) {
  TextReader reader(path_params);
  report("\n--- Parameters ---");
  return true;
}
/*                                              Loss functions                                    */
/**************************************************************************************************/

                                          /***********************/

/**************************************************************************************************/
/*                                          Activation functions                                  */
/// Class for network configuration 
struct MkCNNLayerConfig {}; 

/// Check if the layers input / output size of correct
private Boolean MkCNNLayerConfig.check(io MkCNNLayerInterface layers[]) {
  return true;
}

/// Create and configure the network
public Boolean MkCNNLayerConfig.config(
  String path_def,
  String path_params,
  io MkCNNLayerInterface layers[])
{
  MkCNNLayerDefs layer_defs;
  MkCNNLayerParams layer_params;
  report("\n\n------ Layers ------");

  if(!layer_defs.parse(path_def, layers)) return false;
  if(!layer_params.parse(path_params, layers)) return false;
  if(!this.check(layers)) return false;
  return true;
}

/// Return the number of layer connections
public MkCNNLayerConfig.load() {

}
/*                                              Loss functions                                    */
/**************************************************************************************************/

                                          /***********************/

/**************************************************************************************************/
/*                                          Activation functions                                  */
/// Class for network configuration 
struct MkCNNConfig {
  Index nb_epoch;
  Index optimizer;
  Index batch_size;
  Index loss_function;
  String layers_defs_path;
  String layers_params_path;
  String train_images_path;
  String test_images_path;
  String train_labels_path;
  String test_labels_path;
  MkCNNLayerConfig layer_config;
};

public MkCNNConfig() {
  this.setDefault();
}

public MkCNNConfig.setDefault!() {
  this.nb_epoch = 5;
  this.batch_size = 100;
  
  String input_dir_path = "C:\\Users\\Julien\\Documents\\Dev\\MLKL\\data\\mnist\\";
  this.train_images_path = input_dir_path + "train-images.idx3-ubyte";
  this.test_images_path = input_dir_path + "t10k-images.idx3-ubyte";
  this.train_labels_path = input_dir_path + "train-labels.idx1-ubyte";
  this.test_labels_path = input_dir_path + "t10k-labels.idx1-ubyte";
  
  String layer_dir_path = "C:\\Users\\Julien\\Documents\\Dev\\MLKL\\app\\samples\\cnn\\";
  this.layers_defs_path = layer_dir_path + "layers_def.mlkl";
  this.layers_params_path = layer_dir_path + "layers_params.mlkl";

  this.optimizer = MK_OPTIMIZER_GDLM;
  this.loss_function = MK_LOSS_FUNC_MSE;
}

public Index MkCNNConfig.lossFunction() {
  return this.loss_function;
}

public Index MkCNNConfig.optimizer() {
  return this.optimizer;
}

private Boolean MkCNNConfig.config!(String config_path) {
  report("\n------ Network ------\n");

  report("nb_epoch "            + this.nb_epoch);
  report("optimizer "           + this.optimizer);
  report("batch_size "          + this.batch_size);
  report("loss_function "       + this.loss_function);
  report(" ");
  report("layers_defs_path "    + this.layers_defs_path);
  report("layers_params_path "  + this.layers_params_path);
  report("train_images_path "   + this.train_images_path);
  report("test_images_path "    + this.test_images_path);
  report("train_labels_path "   + this.train_labels_path);
  report("test_labels_path "    + this.test_labels_path);
  return true;
}

public Boolean MkCNNConfig.config!(String config_path, io MkCNNLayerInterface layers[]) {
  report("\n\n\n-------------------- Configuration --------------------");

  if(!this.config(config_path))
    return false;

  return this.layer_config.config(
    this.layers_defs_path, 
    this.layers_params_path, 
    layers);
}
/*                                              Loss functions                                    */
/**************************************************************************************************/

 