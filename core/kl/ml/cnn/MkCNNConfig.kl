/**************************************************************************************************/
/*                                                                                                */
/*  Informations :                                                                                */
/*      This code is part of the project MLKL                                                     */
/*                                                                                                */
/*  Contacts :                                                                                    */
/*      couet.julien@gmail.com                                                                    */
/*                                                                                                */
/**************************************************************************************************/

require FileIO, Util;
require MLKL; 

/**
  The AlembicArchiveReader is a wrapper for the AlembicIArchive. 
  It provides access to the higher level reader objects such as the AlembicXformReader.
  \example

  require MLKL;

  operator entry() {}

  \endexample
*/


/**************************************************************************************************/
/*                                          Activation functions                                  */
/// Class for network layers configuration 
struct MkCNNLayerConfig {}; 

/// Parse the layers configuration parameter relative to the activation function
private Boolean MkCNNLayerConfig.parseNeuronFunction(
  String line, 
  io Index neuron_func)
{
  if(line == "id") { 
    neuron_func = MK_NEURON_IDENTITY; 
    return true; 
  }
  else if(line == "sig") { 
    neuron_func = MK_NEURON_SIGMOID; 
    return true; 
  }
  else if(line == "relu") {
    neuron_func = MK_NEURON_RECTIFIEDLINEAR; 
    return true; 
  }
  else if(line == "tanh") { 
    neuron_func = MK_NEURON_TANH; 
    return true; 
  }
  else return false;
}

/// Parse a string input
private String MkCNNLayerConfig.parseStr(String template, String line) {
  return line.subString(line.find(template) + String(template).length(), line.length());
}

/// Parse a interger input
private Index MkCNNLayerConfig.parseInt(String template, String line) {
  String str = this.parseStr(template, line);
  return Index(str.toInteger());
}

/// Parse a scalar input
private Float64 MkCNNLayerConfig.parseScalar(String template, String line) {
  String str = this.parseStr(template, line);
  return Float64(str.toScalar());
}

/// TO-DO
/// Parse the layers configuration and create them
private Boolean MkCNNLayerConfig.parseData(
  String layer_name,
  io TextReader reader, 
  io MkCNNLayerInterface layers[]) 
{

  return true;
}

/// Parse the layers configuration and create them
private Boolean MkCNNLayerConfig.parseConvolutional(
  String layer_name,
  io TextReader reader, 
  io MkCNNLayerInterface layers[]) 
{
  Index neuron_func, in_size, window_size;
  Index in_channels, out_channels, params_counter = 0;
  Float64 init_w, init_b;

  String line = reader.readLine();
  if(line.find("neuron=") > -1) {
    String str = this.parseStr("neuron=", line);
    if(this.parseNeuronFunction(str, neuron_func)) 
      params_counter ++;    
    line = reader.readLine();
  }
  if(line.find("filters=") > -1) {
    in_size = this.parseInt("filters=", line);
    params_counter ++; line = reader.readLine();  
  }
  if(line.find("filterSize=") > -1) {
    window_size = this.parseInt("filterSize=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("inChannels=") > -1) {
    in_channels = this.parseInt("inChannels=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("outChannels=") > -1) {
    out_channels = this.parseInt("outChannels=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("initW=") > -1) {
    init_w = this.parseScalar("initW=", line);
    params_counter ++; line = reader.readLine();      
  }
  if(line.find("initB=") > -1) {
    init_b = this.parseScalar("initB=", line);
    params_counter ++; line = reader.readLine();      
  }

  report("\nConvolutional Layer " + layer_name);
  if(params_counter != 7) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("neuron        : " + neuron_func);
    report("inSize        : " + in_size);
    report("windowSize    : " + window_size);
    report("inChannels    : " + in_channels);
    report("outChannels   : " + out_channels);
    report("initW         : " + init_w);
    report("initB         : " + init_b);

    layers.push(MkCNNLayerConvolutional(
      layer_name, neuron_func,
      in_size, in_size, window_size,  
      in_channels, out_channels, init_w, init_b));

    return true;
  }
}

/// Parse the layers configuration and create them
private Boolean MkCNNLayerConfig.parsePooling(
  String layer_name,
  io TextReader reader,
  io MkCNNLayerInterface layers[]) 
{
  Index pool_type, neuron_func, in_size;
  Index in_channels, pooling_size, params_counter = 0;
  Float64 init_w, init_b;

  String line = reader.readLine();
  if(line.find("pool=") > -1) {
    String str = this.parseStr("pool=", line);
    if(str == "avg") {
      pool_type = 0;
      params_counter ++;    
    }
    else if(str == "max") {
      pool_type = 1;
      params_counter ++;    
    }
    line = reader.readLine();
  }
  if(line.find("neuron=") > -1) {
    String str = this.parseStr("neuron=", line);
    if(this.parseNeuronFunction(str, neuron_func)) 
      params_counter ++;    
    line = reader.readLine();
  }
  if(line.find("filters=") > -1) {
    in_size = this.parseInt("filters=", line);
    params_counter ++; line = reader.readLine();  
  }
  if(line.find("inChannels=") > -1) {
    in_channels = this.parseInt("inChannels=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("poolingSize=") > -1) {
    pooling_size = this.parseInt("poolingSize=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("initW=") > -1) {
    init_w = this.parseScalar("initW=", line);
    params_counter ++; line = reader.readLine();      
  }
  if(line.find("initB=") > -1) {
    init_b = this.parseScalar("initB=", line);
    params_counter ++; line = reader.readLine();      
  }
 
  report("\nPooling Layer " + layer_name);
  if(params_counter != 7) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("pool          : " + pool_type);
    report("neuron        : " + neuron_func);
    report("inSize        : " + in_size);
    report("inChannels    : " + in_channels);
    report("poolingSize   : " + pooling_size);
    report("initW         : " + init_w);
    report("initB         : " + init_b);

    if(pool_type == 0)
      layers.push(MkCNNLayerAveragePooling(
        layer_name, neuron_func,in_size, in_size,  
        in_channels, pooling_size, init_w, init_b));
    else
      layers.push(MkCNNLayerMaxPooling(
        layer_name, neuron_func,in_size, in_size,  
        in_channels, pooling_size, init_w, init_b));

    return true;
  }
}
 
/// Parse the layers configuration and create them
private Boolean MkCNNLayerConfig.parseFully(
  String layer_name,
  io TextReader reader, 
  io MkCNNLayerInterface layers[]) 
{
  Index neuron_func, in_channels, out_channels, params_counter = 0;
  Float64 init_w, init_b;

  String line = reader.readLine();
  if(line.find("neuron=") > -1) {
    String str = this.parseStr("neuron=", line);
    if(this.parseNeuronFunction(str, neuron_func)) 
      params_counter ++;    
    line = reader.readLine();
  }
  if(line.find("inChannels=") > -1) {
    in_channels = this.parseInt("inChannels=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("outChannels=") > -1) {
    out_channels = this.parseInt("outChannels=", line);
    params_counter ++; line = reader.readLine();    
  }
  if(line.find("initW=") > -1) {
    init_w = this.parseScalar("initW=", line);
    params_counter ++; line = reader.readLine();      
  }
  if(line.find("initB=") > -1) {
    init_b = this.parseScalar("initB=", line);
    params_counter ++; line = reader.readLine();      
  }

  report("\nFully-Connected Layer " + layer_name);
  if(params_counter != 5) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("neuron        : " + neuron_func);
    report("inChannels    : " + in_channels);
    report("outChannels   : " + out_channels);
    report("initW         : " + init_w);
    report("initB         : " + init_b);

    layers.push(MkCNNLayerFully(layer_name, neuron_func, 
      in_channels, out_channels, init_w, init_b));

    return true;
  }
}

/// Parse the layers configuration and create them
public Boolean MkCNNLayerConfig.parseDefs(String path_def, io MkCNNLayerInterface layers[]) {

  TextReader reader();
  if(!reader.open(path_def)) 
    return false;

  report("\n--- Definition ---");
  while(!reader.eof()) 
  {
    String line = reader.readLine();
 
    // Pass comment
    if(line[0] == "#") 
      line = reader.readLine();

    // If we hit a new layer
    if(line[0] == "[")
    {
      String layer_name = line;
      String layer_type = reader.readLine();

      if(layer_type == "type=data") 
      {
        if(!this.parseData(layer_name, reader, layers)) 
          return false;
      }
      else if(layer_type == "type=conv") 
      {
        if(!this.parseConvolutional(layer_name, reader, layers)) 
          return false;
      }
      else if(layer_type == "type=pool") 
      {
        if(!this.parsePooling(layer_name, reader, layers)) 
          return false;
      }
      else if(layer_type == "type=fc") 
      {
        if(!this.parseFully(layer_name, reader, layers)) 
          return false;
      }
    }
  }

  return reader.close();
}

/// TO-complete
/// Parse the layers initial parameters
public Boolean MkCNNLayerConfig.parseParams(String path_params, io MkCNNLayerInterface layers[]) {

  report("\n--- Parameters ---");

  TextReader reader();
  if(!reader.open(path_params))
    return false;

  Float32 epsW, epsB, momW, momB, wc;
  while(!reader.eof()) 
  {
    String line = reader.readLine();

    // Pass comment
    if(line[0] == "#") line = reader.readLine();
 
    // If we hit a new layer
    if(line[0] == "[")
    {
      Index params_counter = 0;

      String layer_name = line;
      line = reader.readLine();

      if(line.find("epsW=") > -1) {
        String str = line.subString(line.find("epsW=") + String("epsW=").length(), line.length());
        epsW = Float32(str.toScalar());
        params_counter ++;  
        line = reader.readLine();
      }

      if(line.find("epsB=") > -1) {
        String str = line.subString(line.find("epsB=") + String("epsB=").length(), line.length());
        epsB = Float32(str.toScalar());
        params_counter ++; 
        line = reader.readLine(); 
      }

      if(line.find("momW=") > -1) {
        String str = line.subString(line.find("momW=") + String("momW=").length(), line.length());
        momW = Float32(str.toScalar());
        params_counter ++;
        line = reader.readLine();  
      }

      if(line.find("momB=") > -1) {
        String str = line.subString(line.find("momB=") + String("momB=").length(), line.length());
        momB = Float32(str.toScalar());
        params_counter ++; 
        line = reader.readLine(); 
      }

      if(line.find("wc=") > -1) {
        String str = line.subString(line.find("wc=") + String("wc=").length(), line.length());
        wc = Float32(str.toScalar());
        params_counter ++; 
      }

      report("\nParameters of " + layer_name);
      if(params_counter != 5) {
        report("Error, wrong parameter order");
        return false;
      }
      else {
        report("epsW          : " + epsW);
        report("epsB          : " + epsB);
        report("momW          : " + momW);
        report("momB          : " + momB);
        report("wc            : " + wc);
      }
    }
  }

  return reader.close();
}
/*                                              Loss functions                                    */
/**************************************************************************************************/

                                          /***********************/

/**************************************************************************************************/
/*                                          Activation functions                                  */
/// Class for network configuration 
struct MkCNNConfig {
  Index worker;
  Index gpu;
  Index nb_epoch;
  Index optimizer;
  Index batch_size;
  Index loss_function;
  String layers_defs_path;
  String layers_params_path;
  String train_images_path;
  String test_images_path;
  String train_labels_path;
  String test_labels_path;
  String output_dir_path;
};

/// Constructor
public MkCNNConfig() {
  this.setDefault();
}

public MkCNNConfig.setDefault!() {
  this.nb_epoch = 5;
  this.batch_size = 100;
  
  String input_dir_path = "C:\\Users\\Julien\\Documents\\Dev\\MLKL\\data\\mnist\\";
  this.train_images_path = input_dir_path + "train-images.idx3-ubyte";
  this.test_images_path = input_dir_path + "t10k-images.idx3-ubyte";
  this.train_labels_path = input_dir_path + "train-labels.idx1-ubyte";
  this.test_labels_path = input_dir_path + "t10k-labels.idx1-ubyte";
  
  String layer_dir_path = "C:\\Users\\Julien\\Documents\\Dev\\MLKL\\app\\samples\\cnn\\";
  this.layers_defs_path = layer_dir_path + "layers_def.mlkl";
  this.layers_params_path = layer_dir_path + "layers_params.mlkl";

  this.optimizer = MK_OPTIMIZER_GDLM;
  this.loss_function = MK_LOSS_MSE;
}

public Index MkCNNConfig.lossFunction() {
  return this.loss_function;
}

public Index MkCNNConfig.optimizer() {
  return this.optimizer;
}

private Boolean MkCNNConfig.parse!(String config_path) {
  TextReader reader();

  if(!reader.open(config_path))
    return false;

  Index params_counter = 0;
  while(!reader.eof()) 
  {
    String line = reader.readLine();
 
    // Pass comment
    if(line[0] == "#") 
      line = reader.readLine();

    if(line.find("worker=") > -1) {
      String str = line.subString(line.find("worker=") + String("worker=").length(), line.length());
      this.worker = Index(str.toInteger());
      params_counter ++;  
    }

    if(line.find("gpu=") > -1) {
      String str = line.subString(line.find("gpu=") + String("gpu=").length(), line.length());
      this.gpu = Index(str.toInteger());
      params_counter ++;  
    }

    if(line.find("nbEpoch=") > -1) {
      String str = line.subString(line.find("nbEpoch=") + String("nbEpoch=").length(), line.length());
      this.nb_epoch = Index(str.toInteger());
      params_counter ++;  
    }

    if(line.find("batchSize=") > -1) {
      String str = line.subString(line.find("batchSize=") + String("batchSize=").length(), line.length());
      this.batch_size = Index(str.toInteger());
      params_counter ++;  
    }

    if(line.find("optimizer=") > -1) {
      String str = line.subString(line.find("optimizer=") + String("optimizer=").length(), line.length());
      this.optimizer = Index(str.toInteger());
      params_counter ++;  
    }

    if(line.find("lossFunction=") > -1) {
      String str = line.subString(line.find("lossFunction=") + String("lossFunction=").length(), line.length());
      this.loss_function = Index(str.toInteger());
      params_counter ++;  
    }

    if(line.find("layersDefsPath=") > -1) {
      this.layers_defs_path = line.subString(line.find("layersDefsPath=") + String("layersDefsPath=").length(), line.length());
      params_counter ++;  
    }

    if(line.find("layersParamsPath=") > -1) {
      this.layers_params_path = line.subString(line.find("layersParamsPath=") + String("layersParamsPath=").length(), line.length());
      params_counter ++;  
    }

    if(line.find("trainImagesPath=") > -1) {
      this.train_images_path = line.subString(line.find("trainImagesPath=") + String("trainImagesPath=").length(), line.length());
      params_counter ++;  
    }

    if(line.find("testImagesPath=") > -1) {
      this.test_images_path = line.subString(line.find("testImagesPath=") + String("testImagesPath=").length(), line.length());
      params_counter ++;  
    }

    if(line.find("trainLabelsPath=") > -1) {
      this.train_labels_path = line.subString(line.find("trainLabelsPath=") + String("trainLabelsPath=").length(), line.length());
      params_counter ++;  
    }

    if(line.find("testLabelsPath=") > -1) {
      this.test_labels_path = line.subString(line.find("testLabelsPath=") + String("testLabelsPath=").length(), line.length());
      params_counter ++;  
    }
  }

  if(params_counter != 12) {
    report("Error, wrong parameter order");
    return false;
  }
  else {
    report("worker        : " + this.worker);
    report("gpu           : " + this.gpu);
    report("nbEpochs      : " + this.nb_epoch);
    report("optimizer     : " + this.optimizer);
    report("batchSize     : " + this.batch_size);
    report("lossFunction  : " + this.loss_function);
    report("");
    report("layers_defs   : " + this.layers_defs_path);
    report("layers_params : " + this.layers_params_path);
    report("train_images  : " + this.train_images_path);
    report("test_images   : " + this.test_images_path);
    report("train_labels  : " + this.train_labels_path);
    report("test_labels   : " + this.test_labels_path);
  }

  return reader.close();
}

/// To-Do
/// Check if the layers input / output size of correct
private Boolean MkCNNConfig.check(io MkCNNLayerInterface layers[]) {
  return true;
}

/// 
public Boolean MkCNNConfig.config!(String config_path, io MkCNNLayerInterface layers[]) {

  report("\n\n\n-------------------- Configuration --------------------");
  report("\n------------ Network ------------\n");
  if(!this.parse(config_path))
    return false;

  report("\n\n------------ Layers ------------");
  MkCNNLayerConfig layer_config;
  if(!layer_config.parseDefs(this.layers_defs_path, layers)) return false;
  if(!layer_config.parseParams(this.layers_params_path, layers)) return false;
  if(!this.check(layers)) return false;

  return true;
}
/*                                              Loss functions                                    */
/**************************************************************************************************/

 