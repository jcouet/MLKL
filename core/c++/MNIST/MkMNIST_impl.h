#ifndef __KL2EDK_AUTOGEN_MkMNIST_impl__
#define __KL2EDK_AUTOGEN_MkMNIST_impl__

#ifdef KL2EDK_INCLUDE_MESSAGES
  #pragma message ( "Including 'MkMNIST_impl.h'" )
#endif

////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
////////////////////////////////////////////////////////////////
// Generated by kl2edk version 1.15.2
////////////////////////////////////////////////////////////////

#include <FabricEDK.h>
#if FABRIC_EDK_VERSION_MAJ != 1 || FABRIC_EDK_VERSION_MIN != 15
# error "This file needs to be rebuilt for the current EDK version!"
#endif

#include "global.h"

#include "MkMNIST.h"

namespace Fabric { namespace EDK { namespace KL {

  struct MkMNIST::Bits
  {
    ObjectCore __objectCore;
    Data handle;
    Object::Bits __interfaceObjectBits;
  };
  
  inline void MkMNIST::ConstructEmpty( MkMNIST *self )
  {
    self->m_bits = 0;
  }
  
  inline void MkMNIST::ConstructCopy( MkMNIST *self, MkMNIST const *other )
  {
    if ( (self->m_bits = other->m_bits) )
      AtomicUInt32Increment( &self->m_bits->__objectCore.refCount );
  }
  
  inline void MkMNIST::AssignCopy( MkMNIST *self, MkMNIST const *other )
  {
    if ( self->m_bits != other->m_bits )
    {
      Destruct( self );
      ConstructCopy( self, other );
    }
  }
  
  inline void MkMNIST::Destruct( MkMNIST *self )
  {
    if ( self->m_bits
      && AtomicUInt32DecrementAndGetValue( &self->m_bits->__objectCore.refCount ) == 0 )
    {
      ObjectCore *objectCorePtr = &self->m_bits->__objectCore;
      self->m_bits->__objectCore.lTableSwapPtrPtr->get()->lifecycleDestroy(
        &objectCorePtr
        );
    }
  }
  
  inline MkMNIST::MkMNIST()
  {
    ConstructEmpty( this );
  }
  
  inline MkMNIST MkMNIST::Create()
  {
    static KL::SwapPtr<void> const *sp = 0;
    if ( !sp )
    {
      sp = static_cast<KL::SwapPtr<void> const *>(
        s_callbacks.m_lookupGlobalSymbol(
          "sp.function.kl.OO_MkMNIST.createEmpty.io_AS0.OO_MkMNIST",
          55
          )
        );
      if ( !sp )
        throwException(
          "EDK internal error: failed to look up '%s'",
          "sp.function.kl.OO_MkMNIST.createEmpty.io_AS0.OO_MkMNIST"
          );
    }
    void (*createFuncPtr)(void *) = ((void (*)(void *))sp->get());
    if ( !createFuncPtr )
      throwException(
        "EDK internal error: target of '%s' is NULL",
        "sp.function.kl.OO_MkMNIST.createEmpty.io_AS0.OO_MkMNIST"
        );
    MkMNIST result;
    createFuncPtr( &result );
    return result;
  }
  
  inline MkMNIST::MkMNIST( MkMNIST const &that )
  {
    ConstructCopy( this, &that );
  }
  
  inline MkMNIST &MkMNIST::operator =( MkMNIST const &that )
  {
    AssignCopy( this, &that );
    return *this;
  }
  
  inline MkMNIST::~MkMNIST()
  {
    Destruct( this );
  }
  
  inline void MkMNIST::appendDesc( String::IOParam string ) const
  {
    if ( m_bits )
    {
      ObjectCore *objectCorePtr = &m_bits->__objectCore;
      objectCorePtr->lTableSwapPtrPtr->get()->appendDesc(
        &objectCorePtr, string
        );
    }
    else string.append( "null", 4 );
  }
  inline uint32_t MkMNIST::getRefCount() const
  {
    if ( m_bits )
    {
      ObjectCore *objectCorePtr = &m_bits->__objectCore;
      return objectCorePtr->refCount;
    }
    else return 0;
  }
  inline Type MkMNIST::getType() const
  {
    if ( m_bits )
    {
      return Type( m_bits->__objectCore.typeInfoSwapPtrPtr->get() );
    }
    else return Type();
  }
  
  inline bool MkMNIST::isValid() const
  {
    return !!m_bits;
  }
  
  inline MkMNIST::operator bool() const
  {
    return isValid();
  }
  
  inline bool MkMNIST::operator !() const
  {
    return !isValid();
  }
  
  inline MkMNIST::Bits *MkMNIST::operator ->()
  {
    return static_cast<MkMNIST::Bits *>( m_bits );
  }
  
  inline MkMNIST::Bits const *MkMNIST::operator ->() const
  {
    return static_cast<MkMNIST::Bits const *>( m_bits );
  }
  
  inline bool MkMNIST::operator ==( INParam that )
  {
    return m_bits == that.m_bits;
  }
  
  inline bool MkMNIST::operator !=( INParam that )
  {
    return m_bits != that.m_bits;
  }
  
  // Methods for 'Object'

}}}

#endif // __KL2EDK_AUTOGEN_MkMNIST_impl__
