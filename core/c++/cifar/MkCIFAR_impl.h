#ifndef __KL2EDK_AUTOGEN_MkCIFAR_impl__
#define __KL2EDK_AUTOGEN_MkCIFAR_impl__

#ifdef KL2EDK_INCLUDE_MESSAGES
  #pragma message ( "Including 'MkCIFAR_impl.h'" )
#endif

////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
////////////////////////////////////////////////////////////////
// Generated by kl2edk version 1.15.2
////////////////////////////////////////////////////////////////

#include <FabricEDK.h>
#if FABRIC_EDK_VERSION_MAJ != 1 || FABRIC_EDK_VERSION_MIN != 15
# error "This file needs to be rebuilt for the current EDK version!"
#endif

#include "global.h"

#include "MkCIFAR.h"

namespace Fabric { namespace EDK { namespace KL {

  struct MkCIFAR::Bits
  {
    ObjectCore __objectCore;
    Data handle;
    Object::Bits __interfaceObjectBits;
  };
  
  inline void MkCIFAR::ConstructEmpty( MkCIFAR *self )
  {
    self->m_bits = 0;
  }
  
  inline void MkCIFAR::ConstructCopy( MkCIFAR *self, MkCIFAR const *other )
  {
    if ( (self->m_bits = other->m_bits) )
      AtomicUInt32Increment( &self->m_bits->__objectCore.refCount );
  }
  
  inline void MkCIFAR::AssignCopy( MkCIFAR *self, MkCIFAR const *other )
  {
    if ( self->m_bits != other->m_bits )
    {
      Destruct( self );
      ConstructCopy( self, other );
    }
  }
  
  inline void MkCIFAR::Destruct( MkCIFAR *self )
  {
    if ( self->m_bits
      && AtomicUInt32DecrementAndGetValue( &self->m_bits->__objectCore.refCount ) == 0 )
    {
      ObjectCore *objectCorePtr = &self->m_bits->__objectCore;
      self->m_bits->__objectCore.lTableSwapPtrPtr->get()->lifecycleDestroy(
        &objectCorePtr
        );
    }
  }
  
  inline MkCIFAR::MkCIFAR()
  {
    ConstructEmpty( this );
  }
  
  inline MkCIFAR MkCIFAR::Create()
  {
    static KL::SwapPtr<void> const *sp = 0;
    if ( !sp )
    {
      sp = static_cast<KL::SwapPtr<void> const *>(
        s_callbacks.m_lookupGlobalSymbol(
          "sp.function.kl.OO_MkCIFAR.createEmpty.io_AS0.OO_MkCIFAR",
          55
          )
        );
      if ( !sp )
        throwException(
          "EDK internal error: failed to look up '%s'",
          "sp.function.kl.OO_MkCIFAR.createEmpty.io_AS0.OO_MkCIFAR"
          );
    }
    void (*createFuncPtr)(void *) = ((void (*)(void *))sp->get());
    if ( !createFuncPtr )
      throwException(
        "EDK internal error: target of '%s' is NULL",
        "sp.function.kl.OO_MkCIFAR.createEmpty.io_AS0.OO_MkCIFAR"
        );
    MkCIFAR result;
    createFuncPtr( &result );
    return result;
  }
  
  inline MkCIFAR::MkCIFAR( MkCIFAR const &that )
  {
    ConstructCopy( this, &that );
  }
  
  inline MkCIFAR &MkCIFAR::operator =( MkCIFAR const &that )
  {
    AssignCopy( this, &that );
    return *this;
  }
  
  inline MkCIFAR::~MkCIFAR()
  {
    Destruct( this );
  }
  
  inline void MkCIFAR::appendDesc( String::IOParam string ) const
  {
    if ( m_bits )
    {
      ObjectCore *objectCorePtr = &m_bits->__objectCore;
      objectCorePtr->lTableSwapPtrPtr->get()->appendDesc(
        &objectCorePtr, string
        );
    }
    else string.append( "null", 4 );
  }
  inline uint32_t MkCIFAR::getRefCount() const
  {
    if ( m_bits )
    {
      ObjectCore *objectCorePtr = &m_bits->__objectCore;
      return objectCorePtr->refCount;
    }
    else return 0;
  }
  inline Type MkCIFAR::getType() const
  {
    if ( m_bits )
    {
      return Type( m_bits->__objectCore.typeInfoSwapPtrPtr->get() );
    }
    else return Type();
  }
  
  inline bool MkCIFAR::isValid() const
  {
    return !!m_bits;
  }
  
  inline MkCIFAR::operator bool() const
  {
    return isValid();
  }
  
  inline bool MkCIFAR::operator !() const
  {
    return !isValid();
  }
  
  inline MkCIFAR::Bits *MkCIFAR::operator ->()
  {
    return static_cast<MkCIFAR::Bits *>( m_bits );
  }
  
  inline MkCIFAR::Bits const *MkCIFAR::operator ->() const
  {
    return static_cast<MkCIFAR::Bits const *>( m_bits );
  }
  
  inline bool MkCIFAR::operator ==( INParam that )
  {
    return m_bits == that.m_bits;
  }
  
  inline bool MkCIFAR::operator !=( INParam that )
  {
    return m_bits != that.m_bits;
  }
  
  // Methods for 'Object'

}}}

#endif // __KL2EDK_AUTOGEN_MkCIFAR_impl__
